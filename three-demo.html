<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Demo with Morphing Gradient Background</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Load Three.js and GLTFLoader from your Cargo-hosted files -->
  <script src="https://files.cargocollective.com/c390363/three.min.js"></script>
  <script src="https://files.cargocollective.com/c390363/GLTFLoader.js"></script>
  <script>
    // Create the main scene, camera, and renderer.
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Background: Soft morphing gradient ---
    // Create a full-screen quad geometry. UV coordinates will range from 0 to 1.
    const bgGeometry = new THREE.PlaneGeometry(2, 2);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          // Define two base colors.
          vec3 colorA = vec3(0.2, 0.0, 0.8);  // purple-ish
          vec3 colorB = vec3(0.8, 0.0, 0.2);  // reddish

          // Create a time-based factor that oscillates between 0 and 1.
          float t = 0.5 + 0.5 * sin(uTime * 0.5);
          // Mix the two colors.
          vec3 baseColor = mix(colorA, colorB, t);
          
          // Add a vertical gradient effect based on the vUv.y coordinate.
          // You can adjust the gradient intensity by modifying the mix below.
          vec3 finalColor = mix(baseColor * 0.5, baseColor, vUv.y);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      depthWrite: false,
      depthTest: false,
      side: THREE.DoubleSide
    });
    // Create a mesh for the background quad.
    const bgQuad = new THREE.Mesh(bgGeometry, bgMaterial);
    // Set renderOrder so it draws behind other objects.
    bgQuad.renderOrder = -1;
    scene.add(bgQuad);

    // --- 3D Model: Load the moving cube via GLTFLoader ---
    const loader = new THREE.GLTFLoader();
    let mixer;
    const clock = new THREE.Clock();

    loader.load(
      'https://files.cargocollective.com/c390363/cube_move_02.gltf',
      function (gltf) {
        const movingCube = gltf.scene;
        // Position the cube (adjust as needed)
        movingCube.position.set(0, 0, 0);
        scene.add(movingCube);
        console.log("Moving cube loaded successfully.");
        
        // If the model has animations, set up the AnimationMixer.
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(movingCube);
          const action = mixer.clipAction(gltf.animations[0]);
          action.play();
        }
      },
      undefined,
      function (error) {
        console.error("Error loading moving cube:", error);
      }
    );

    // --- Basic lighting so the model is better lit ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      // Update model animation if available.
      if (mixer) mixer.update(delta);
      // Update the gradient background's time uniform.
      bgMaterial.uniforms.uTime.value += delta;
      renderer.render(scene, camera);
    }
    animate();

    // --- Handle Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
