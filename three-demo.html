<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Demo with Two Cubes & Gradient</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Load Three.js and GLTFLoader from your Cargo-hosted files -->
  <script src="https://files.cargocollective.com/c390363/three.min.js"></script>
  <script src="https://files.cargocollective.com/c390363/GLTFLoader.js"></script>
  <script>
    // Create the main scene, camera, and renderer.
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Background: Soft morphing gradient ---
    const bgGeometry = new THREE.PlaneGeometry(2, 2);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          // Define two base colors.
          vec3 colorA = vec3(0.2, 0.0, 0.8);  // purple-ish
          vec3 colorB = vec3(0.8, 0.0, 0.2);  // reddish

          // Create a time-based factor that oscillates between 0 and 1.
          float t = 0.5 + 0.5 * sin(uTime * 0.5);
          vec3 baseColor = mix(colorA, colorB, t);
          
          // Add a vertical gradient effect based on the vUv.y coordinate.
          vec3 finalColor = mix(baseColor * 0.5, baseColor, vUv.y);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      depthWrite: false,
      depthTest: false,
      side: THREE.DoubleSide
    });
    const bgQuad = new THREE.Mesh(bgGeometry, bgMaterial);
    bgQuad.renderOrder = -1;
    scene.add(bgQuad);

    // --- Load the first cube (moving cube) via GLTFLoader ---
    const loader = new THREE.GLTFLoader();
    let mixer; // for animations on the moving cube
    const clock = new THREE.Clock();

    loader.load(
      'https://files.cargocollective.com/c390363/cube_move_02.gltf',
      function (gltf) {
        const movingCube = gltf.scene;
        movingCube.position.set(0, 0, 0);
        scene.add(movingCube);
        console.log("Moving cube loaded successfully.");
        
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(movingCube);
          const action = mixer.clipAction(gltf.animations[0]);
          action.play();
        }
      },
      undefined,
      function (error) {
        console.error("Error loading moving cube:", error);
      }
    );

    // --- Create the second cube (rotating and following the mouse) ---
    let rotatingCube;
    (function createRotatingCube(){
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 0xff00ff });
      rotatingCube = new THREE.Mesh(geometry, material);
      // Set an initial position.
      rotatingCube.position.set(2.5, 0, 0);
      scene.add(rotatingCube);
    })();

    // --- Add basic lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // --- Mouse tracking for rotating cube ---
    const mouse = new THREE.Vector2();
    document.addEventListener("mousemove", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    });

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Update the gradient background
      bgMaterial.uniforms.uTime.value += delta;

      // Update moving cube animation if available
      if (mixer) mixer.update(delta);

      // Update the rotating cube:
      if (rotatingCube) {
        // Slowly rotate it
        rotatingCube.rotation.x += 0.01;
        rotatingCube.rotation.y += 0.01;
        // Convert mouse position (NDC) to world coordinates at a fixed Z plane.
        // Create a vector with z = 0.5 (middle of clip space) and unproject.
        const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject(camera);
        // Optionally, smooth the movement using .lerp:
        rotatingCube.position.lerp(vector, 0.1);
      }

      renderer.render(scene, camera);
    }
    animate();

    // --- Handle Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
