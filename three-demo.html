<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Demo with Two GLTF Cubes & Gradient</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  test 01
  <!-- Load Three.js and GLTFLoader from your Cargo-hosted files -->
  <script src="https://files.cargocollective.com/c390363/three.min.js"></script>
  <script src="https://files.cargocollective.com/c390363/GLTFLoader.js"></script>
  <script>
    // --- Scene, Camera, Renderer ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Background: Soft Morphing Gradient ---
    const bgGeometry = new THREE.PlaneGeometry(2, 2);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vec3 colorA = vec3(0.2, 0.0, 0.8);  // purple-ish
          vec3 colorB = vec3(0.8, 0.0, 0.2);  // reddish
          float t = 0.5 + 0.5 * sin(uTime * 0.5);
          vec3 baseColor = mix(colorA, colorB, t);
          vec3 finalColor = mix(baseColor * 0.5, baseColor, vUv.y);
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      depthWrite: false,
      depthTest: false,
      side: THREE.DoubleSide
    });
    const bgQuad = new THREE.Mesh(bgGeometry, bgMaterial);
    bgQuad.renderOrder = -1;
    scene.add(bgQuad);

    // --- Basic Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // --- Load the Moving Cube (GLTF Model) ---
    const loader = new THREE.GLTFLoader();
    let movingCubeMixer;
    const clock = new THREE.Clock();
    let movingCube;
    loader.load(
      'https://files.cargocollective.com/c390363/cube_move_02.gltf',
      function (gltf) {
        movingCube = gltf.scene;
        // Position the moving cube to the left.
        movingCube.position.set(-1.5, 0, 6);
        scene.add(movingCube);
        console.log("Moving cube loaded successfully.");

        // If the model has animations, set up an AnimationMixer.
        if (gltf.animations && gltf.animations.length > 0) {
          movingCubeMixer = new THREE.AnimationMixer(movingCube);
          const action = movingCubeMixer.clipAction(gltf.animations[0]);
          action.play();
        }
      },
      undefined,
      function (error) {
        console.error("Error loading moving cube:", error);
      }
    );

    // --- Load the Rotating Cube (GLTF Model) ---
    let rotatingCube;
    loader.load(
      'https://files.cargocollective.com/c390363/cube_rotate_03.gltf',
      function (gltf) {
        rotatingCube = gltf.scene;
        // Position the rotating cube to the right.
        rotatingCube.position.set(1.5, 0, 6);
        scene.add(rotatingCube);
        console.log("Rotating cube loaded successfully.");
      },
      undefined,
      function (error) {
        console.error("Error loading rotating cube:", error);
      }
    );

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Update gradient background.
      bgMaterial.uniforms.uTime.value += delta;

      // Update moving cube animation if available.
      if (movingCubeMixer) movingCubeMixer.update(delta);

      // Slowly rotate the rotating cube.
      if (rotatingCube) {
        rotatingCube.rotation.x += 0.01;
        rotatingCube.rotation.y += 0.01;
      }

      renderer.render(scene, camera);
    }
    animate();

    // --- Handle Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
