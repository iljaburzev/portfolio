<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Demo with Communication - Test 03</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  Test 03
  <!-- You can leave any text you want here; it won't be visible if the canvas covers the screen -->
  <script src="https://files.cargocollective.com/c390363/three.min.js"></script>
  <script src="https://files.cargocollective.com/c390363/GLTFLoader.js"></script>
  <script>
    // --- Basic Scene Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Background: Soft Morphing Gradient ---
    const bgGeometry = new THREE.PlaneGeometry(2, 2);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0.0 } },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vec3 colorA = vec3(0.2, 0.0, 0.8);
          vec3 colorB = vec3(0.8, 0.0, 0.2);
          float t = 0.5 + 0.5 * sin(uTime * 0.5);
          vec3 baseColor = mix(colorA, colorB, t);
          vec3 finalColor = mix(baseColor * 0.5, baseColor, vUv.y);
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      depthWrite: false,
      depthTest: false,
      side: THREE.DoubleSide
    });
    const bgQuad = new THREE.Mesh(bgGeometry, bgMaterial);
    bgQuad.renderOrder = -1;
    scene.add(bgQuad);

    // --- Basic Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // --- Load a GLTF Model (example moving cube) ---
    const loader = new THREE.GLTFLoader();
    let movingCubeMixer;
    const clock = new THREE.Clock();
    loader.load(
      'https://files.cargocollective.com/c390363/cube_move_02.gltf',
      function (gltf) {
        const movingCube = gltf.scene;
        movingCube.position.set(-1.5, 0, 6);
        scene.add(movingCube);
        console.log("Moving cube loaded successfully.");
        if (gltf.animations && gltf.animations.length > 0) {
          movingCubeMixer = new THREE.AnimationMixer(movingCube);
          const action = movingCubeMixer.clipAction(gltf.animations[0]);
          action.play();
        }
      },
      undefined,
      function (error) {
        console.error("Error loading moving cube:", error);
      }
    );

    // --- Load another GLTF Model (example rotating cube) ---
    let rotatingCube;
    loader.load(
      'https://files.cargocollective.com/c390363/cube_rotate_03.gltf',
      function (gltf) {
        rotatingCube = gltf.scene;
        rotatingCube.position.set(1.5, 0, 6);
        scene.add(rotatingCube);
        console.log("Rotating cube loaded successfully.");
      },
      undefined,
      function (error) {
        console.error("Error loading rotating cube:", error);
      }
    );

    // --- Listen for Messages from Parent ---
    window.addEventListener("message", (event) => {
      // Optionally, check event.origin if you want to restrict messages.
      if (event.data && event.data.type === "createCube") {
        console.log("Received message to create a new cube.");
        // Create a new cube.
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
        const newCube = new THREE.Mesh(geometry, material);
        // Position the new cube at a chosen location (here, center at z = 6).
        newCube.position.set(0, 0, 6);
        scene.add(newCube);
      }
    });

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      bgMaterial.uniforms.uTime.value += delta;
      if (movingCubeMixer) movingCubeMixer.update(delta);
      if (rotatingCube) {
        rotatingCube.rotation.x += 0.01;
        rotatingCube.rotation.y += 0.01;
      }
      renderer.render(scene, camera);
    }
    animate();

    // --- Handle Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
